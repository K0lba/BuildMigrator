import argparse
from bisect import bisect
from difflib import Differ
from functools import reduce
import os
import sys

import logging

logging.basicConfig(format="%(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)


# Merges two or more similar CMakeLists.txt files
# CMake parser is currently really naive and may only work for files generated by generate_cmake
# TODO: improve CMake parser


def indent(str):
    return "    " + str.replace("\n", "\n    ")


def merge_tagged_lines(tagged_lines_a, tagged_lines_b):
    differ = Differ()

    lines_a = [tl[0] for tl in tagged_lines_a]
    lines_b = [tl[0] for tl in tagged_lines_b]
    known_tags = set()
    tags_a = [known_tags.update(tl[1]) or tl[1] for tl in tagged_lines_a]
    tags_b = [known_tags.update(tl[1]) or tl[1] for tl in tagged_lines_b]

    tags_a_iter = iter(tags_a)
    tags_b_iter = iter(tags_b)
    result = []
    empty_lines_pending = None
    for line in differ.compare(lines_a, lines_b):
        tags = None
        is_empty = len(line[2:]) == 0
        is_common = False
        if line.startswith("  "):  # present in both files
            tags = next(tags_a_iter) + next(tags_b_iter)
            is_common = len(tags) == len(known_tags)
        elif line.startswith("- "):  # in 'a' only
            tags = next(tags_a_iter)
        elif line.startswith("+ "):  # in 'b' only
            tags = next(tags_b_iter)
        else:
            continue

        if is_empty and empty_lines_pending is not None:
            empty_lines_pending.append(tags)
            continue
        else:
            if empty_lines_pending:
                for empty_line_tags in empty_lines_pending:
                    if not is_common:
                        for t in empty_line_tags:
                            result.append(("", [t]))
                    else:
                        result.append(("", tags))
            if is_common:
                empty_lines_pending = None
            else:
                empty_lines_pending = []
            result.append((line[2:], tags))

    if empty_lines_pending:
        for tags in empty_lines_pending:
            result.append(("", tags))

    for tag_iter in [tags_a_iter, tags_b_iter]:
        try:
            next(tag_iter)
            assert False  # must've reached the end
        except StopIteration:
            pass

    return result


# Group adjacent tagged lines with same condition
# Overall line order after filtering lines by condition should not change
#
# Example:
#  line1, [cond1]          1.
#  line2, [cond2]          .1
#  line3, [cond1]          2.
#  line4, [cond1, cond2]   32
#  line5, [cond2]          .3
# Result:
#  line1, [cond1]          1.
#  line3, [cond1]          2.
#  line2, [cond2]          .1
#  line4, [cond1, cond2]   32
#  line5, [cond2]          .3
def group_tagged_lines(tagged_lines, known_tags):
    known_tags = sorted(known_tags)
    tag_counter = {tag: 0 for tag in known_tags}
    tag_index = {tag: line_idx for line_idx, tag in enumerate(known_tags)}
    data = []
    for item in tagged_lines:
        tags = item[1]
        tag_positions = [None] * len(known_tags)
        for tag in tags:
            value = tag_counter[tag]
            tag_positions[tag_index[tag]] = value
            tag_counter[tag] = value + 1
        data.append(tag_positions)

    result = []
    for tag_idx in range(0, len(known_tags)):
        result_lines_for_tag = []
        for res_idx, line_idx in enumerate(result):
            tag_pos = data[line_idx][tag_idx]
            if tag_pos is not None:
                result_lines_for_tag.append((tag_pos, res_idx))

        for line_idx, tag_positions in enumerate(data):
            if line_idx in result:
                continue
            tag_pos = tag_positions[tag_idx]
            if tag_pos is None:
                continue
            idx = bisect(result_lines_for_tag, (tag_pos, line_idx))
            if idx < len(result_lines_for_tag):
                result_idx = result_lines_for_tag[idx][1]
            else:
                result_idx = len(result)
            result.insert(result_idx, line_idx)
            for update_idx, r in enumerate(result_lines_for_tag):
                if r[1] >= result_idx:
                    result_lines_for_tag[update_idx] = (r[0], r[1] + 1)
            result_lines_for_tag.insert(idx, (tag_pos, result_idx))

    # Reorder tagged_lines according to result
    return [tagged_lines[idx] for idx in result]


def format_disjuntive_expression(conjuncts):
    if len(conjuncts) > 1:
        # CMake has unexpected order of precedence inside if()
        # https://gitlab.kitware.com/cmake/cmake/-/issues/18613
        conjuncts = map(lambda s: "(" + s + ")" if " AND " in s else s, conjuncts)
    lines = [""]
    for expr in conjuncts:
        if lines[-1]:
            if len(lines[-1]) > 80:
                lines.append("    OR ")
            else:
                lines[-1] += " OR "
        lines[-1] += expr
    return "\n".join(lines)


def merge_cmake(infiles, outfile):
    cmakefiles = []
    all_conditions = []
    for path in infiles:
        assert os.path.exists(path), path
        with open(path) as f:
            condition = f.readline()
            logger.info(
                "Get condition {condition} from {path}".format(
                    condition=condition, path=path
                )
            )
            assert condition.startswith("#"), condition
            condition = condition[1:].strip()
            if condition in all_conditions:
                raise ValueError("Duplicate condition: {}".format(condition))
            all_conditions.append(condition)
            expressions = []
            expr_complete = True
            for line in f:
                line = line.rstrip()
                line_ls = line.lstrip()

                if expr_complete:
                    if not line_ls:  # empty line
                        pass
                    elif line_ls[0] == "#":  # comment
                        pass
                    else:  # CMake command begin
                        idx = line_ls.find("(")
                        assert idx > 0, line
                        function = line_ls[0:idx].rstrip()
                        assert function, line
                        expr_complete = False
                    expressions.append(line)
                else:
                    expressions[-1] += "\n" + line

                if not expr_complete and line.endswith(")"):  # CMake command end
                    expr_complete = True

            assert expr_complete
            tagged_lines = [(expr, [condition]) for expr in expressions]
            cmakefiles.append(tagged_lines)

    all_conditions = sorted(all_conditions)

    def sort_key(tagged_lines):
        if len(tagged_lines) > 0:
            return tagged_lines[0][1]
        else:
            return None

    cmakefiles = sorted(cmakefiles, key=sort_key)
    tagged_lines = reduce(merge_tagged_lines, cmakefiles)
    tagged_lines = [(line, (sorted(conditions))) for line, conditions in tagged_lines]
    tagged_lines = group_tagged_lines(tagged_lines, all_conditions)

    toolchain_verification_pending = None
    endif_pending = False
    prev_conditions = None
    empty_line_pending = False
    with open(outfile, "wt") as f:
        for line, conditions in tagged_lines:
            if toolchain_verification_pending:
                f.write(
                    "if(NOT (" + format_disjuntive_expression(all_conditions) + "))\n"
                )
                f.write(
                    '    message(FATAL_ERROR "Current toolchain is not supported by this project [ ${CMAKE_SYSTEM_NAME} ${CMAKE_SYSTEM_PROCESSOR} ${CMAKE_SIZEOF_VOID_P} ${CMAKE_C_COMPILER_ID} ${CMAKE_CXX_COMPILER_ID} ]")\n'
                )
                f.write("endif()\n")
                toolchain_verification_pending = False

            if line.startswith("project(") and toolchain_verification_pending is None:
                toolchain_verification_pending = True

            if len(line.strip()) == 0:
                empty_line_pending = True
                continue

            if conditions != prev_conditions:
                if endif_pending:
                    f.write("endif()\n")
                    endif_pending = False

            if empty_line_pending:
                f.write("\n")
                empty_line_pending = False

            if conditions != prev_conditions:
                prev_conditions = conditions
                if len(conditions) != len(all_conditions):
                    f.write("if(" + format_disjuntive_expression(conditions) + ")\n")
                    endif_pending = True

            if endif_pending:
                line = indent(line)
            f.write(line + "\n")

        if endif_pending:
            f.write("endif()\n")


arg_parser = argparse.ArgumentParser(prog="cmake_merge")
arg_parser.add_argument("infiles", metavar="infile", nargs="+")
arg_parser.add_argument("outfile")


def main(argv=sys.argv[1:]):
    cfg = arg_parser.parse_args(argv)
    merge_cmake(cfg.infiles, cfg.outfile)


if __name__ == "__main__":
    main()
